//
//  PublishableObservationRegistrar.swift
//  Publishable
//
//  Created by Kamil Strzelecki on 18/01/2025.
//  Copyright Â© 2025 Kamil Strzelecki. All rights reserved.
//

import Observation

@_documentation(visibility: private)
public protocol PublishableObservationRegistrar {

    associatedtype Object: Publishable, Observable

    var underlying: SwiftObservationRegistrar { get }

    func publish(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    )
}

extension PublishableObservationRegistrar {

    public func willSet(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    ) {
        object.publisher.beginModifications()
        underlying.willSet(object, keyPath: keyPath)
    }

    public func didSet(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    ) {
        underlying.didSet(object, keyPath: keyPath)
        publish(object, keyPath: keyPath)
        object.publisher.endModifications()
    }

    public func access(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    ) {
        underlying.access(object, keyPath: keyPath)
    }

    public func withMutation<T>(
        of object: Object,
        keyPath: KeyPath<Object, some Any>,
        _ mutation: () throws -> T
    ) rethrows -> T {
        object.publisher.beginModifications()
        let result = try underlying.withMutation(of: object, keyPath: keyPath, mutation)
        publish(object, keyPath: keyPath)
        object.publisher.endModifications()
        return result
    }
}

@_documentation(visibility: private)
public protocol MainActorPublishableObservationRegistrar {

    associatedtype Object: MainActorPublishable, Observable

    var underlying: SwiftObservationRegistrar { get }

    @MainActor
    func publish(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    )
}

extension MainActorPublishableObservationRegistrar {

    @MainActor
    public func willSet(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    ) {
        object.publisher.beginModifications()
        underlying.willSet(object, keyPath: keyPath)
    }

    @MainActor
    public func didSet(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    ) {
        underlying.didSet(object, keyPath: keyPath)
        publish(object, keyPath: keyPath)
        object.publisher.endModifications()
    }

    public func access(
        _ object: Object,
        keyPath: KeyPath<Object, some Any>
    ) {
        underlying.access(object, keyPath: keyPath)
    }

    public func withMutation<T>(
        of object: Object,
        keyPath: KeyPath<Object, some Any>,
        _ mutation: () throws -> T
    ) rethrows -> T {
      try withoutActuallyEscaping(mutation) { mutation in
        // withMutation is called from a nonisolated function generated by @Observable, but in
        // practice if the object is MainActorPublishable, we can assume that the mutation is
        // isolated to the MainActor.
        try MainActor.assumeIsolated { [unchecked = UncheckedSendable(wrappedValue: (self, object, keyPath, mutation))] in
          unchecked.wrappedValue.1.publisher.beginModifications()
          let result = try unchecked.wrappedValue.0.underlying.withMutation(of: unchecked.wrappedValue.1, keyPath: unchecked.wrappedValue.2, unchecked.wrappedValue.3)
          unchecked.wrappedValue.0.publish(unchecked.wrappedValue.1, keyPath: unchecked.wrappedValue.2)
          unchecked.wrappedValue.1.publisher.endModifications()
          return UncheckedSendable(wrappedValue: result)
        }
      }.wrappedValue
    }
}

struct UncheckedSendable<Value>: @unchecked Sendable {
    var wrappedValue: Value

    init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }
}
