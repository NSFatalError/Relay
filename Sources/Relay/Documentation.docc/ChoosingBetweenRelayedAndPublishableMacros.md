# Choosing between @Relayed and @Publishable macros

Determine which macro best fits your use cases.

## Overview

The ``Relayed()`` and ``Publishable()`` macros both enable observation of property updates through `Combine` 
on your `Observable` classes, but they achieve this through different mechanisms.

As a general rule:
- Prefer ``Relayed()`` macro when the class uses the `@Observable` macro.
- Prefer ``Publishable()`` macro when the class uses a different macro to provide `Observable` conformance.

The table below highlights the key similarities and differences between the macros:

Feature | `@Relayed` | `@Publishable`
--- | --- | ---
``Publishable`` conformance | Generated by the macro | Generated by the macro
Publishing changes through `Combine` | Direct | Uses key path comparison after each mutation (_O(n)_, where _n_ is the number of stored mutable properties)
`Observable` conformance | Generated by the macro | Provided by another `@Observable`-like macro
Publishing changes through `Observation` | Direct | Depends on the macro providing `Observable` conformance
Compatibility | Only applicable to classes using the `@Observable` macro directly | Should compile alongside macros that follow `@Observable`-like expansion pattern
Special considerations | Does not generate methods equivalent to `access` and `withMutation`, but otherwise replicates the `@Observable` macro expansion | Generates a custom `ObservationRegistrar` type, which might be unexpected for frameworks using reflection (e.g., `SwiftData` and its `@Model` macro)

## Overloading ObservationRegistrar

What makes the ``Publishable()`` macro compatible with other macros that follow the `@Observable`-like expansion pattern,
including the `@Observable` macro itself, stems from two key properties of Swift Macros and `Observation` module:
- Macro expansions are compiled in the context of the module where they’re used. This allows references in the macro to be overloaded by locally available symbols.
- Swift exposes `ObservationRegistrar` as a documented, public API, making it possible to use it safely and directly.

By leveraging these facts, the ``Publishable()`` macro can overload the default `ObservationRegistrar` with a custom one that:
- Forwards changes to Swift’s native `ObservationRegistrar`
- Simultaneously emits values through generated `Combine` publishers by comparing key paths after each property mutation

While I acknowledge that this usage might not have been intended by the authors, I would refrain from calling it a hack.
It relies solely on well-understood behaviors of Swift and its public APIs.

The ``Relayed()`` macro does not depend on this mechanism, making it potentially safer and more performant, 
though incompatible with other macros generating `Observable` conformance.
